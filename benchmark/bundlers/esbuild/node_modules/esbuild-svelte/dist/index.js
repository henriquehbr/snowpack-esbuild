const { preprocess, compile } = require('svelte/compiler');
const { relative } = require('path');
const { promisify } = require('util');
const { readFile } = require('fs');
const convertMessage = ({message, start, end, filename, frame}) => ({
  text: message,
  location: start && end && {
    file: filename,
    line: start.line,
    column: start.column,
    length: start.line === end.line ? end.column - start.column : 0,
    lineText: frame
  }
});
function sveltePlugin(options) {
  return {
    name: "esbuild-svelte",
    setup(build) {
      const cssCode = new Map();
      build.onLoad({filter: /\.svelte$/}, async (args) => {
        let source = await promisify(readFile)(args.path, "utf8");
        let filename = relative(process.cwd(), args.path);
        try {
          if (options && options.preprocessor) {
            source = (await preprocess(source, options.preprocessor, {filename})).code;
          }
          let compileOptions = {css: false, ...options && options.compileOptions};
          let {js, css, warnings} = compile(source, {...compileOptions, filename});
          let contents = js.code + `
//# sourceMappingURL=` + js.map.toUrl();
          if (!compileOptions.css && css.code) {
            let cssPath = args.path.replace(".svelte", ".esbuild-svelte-fake-css").replace(/\\/g, "/");
            cssCode.set(cssPath, css.code + `/*# sourceMappingURL=${css.map.toUrl()}*/`);
            contents = contents + `
require('${cssPath}');`;
          }
          return {contents, warnings: warnings.map(convertMessage)};
        } catch (e) {
          return {errors: [convertMessage(e)]};
        }
      });
      build.onLoad({filter: /\.esbuild-svelte-fake-css$/}, (args) => {
        const css = cssCode.get(args.path);
        return css ? {contents: css, loader: "css"} : null;
      });
    }
  };
}
module.exports = sveltePlugin;
